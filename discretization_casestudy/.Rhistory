for(rep in 1: nrow(Nj_hat_replicate)){
prediction_ps_replicate = c(prediction_ps_replicate,
apply( prediction, 1, function(x){
sum(Nj_hat_replicate[rep,] * x) / sum(Nj_hat_replicate[rep,])
}))
}
## Organise the output
N = length(population_$logRENTcentered)
theta_mean = colMeans(prediction)
theta_cov = cov(prediction)
tibble(mean_logRENT = mean(prediction_ps),
mean_logRENT_true = mean(prediction_ps_true),
poststrat_variance_trueNj = var(prediction_ps_true),
poststrat_variance_estNj = var(prediction_ps),
poststrat_variance_replicatewts = var(prediction_ps_replicate),
term1 = sum(diag(theta_cov %*% Nj_cov)) / N^2,
term2 = (t(poststrat$Nj_hat) %*% theta_cov %*% poststrat$Nj_hat) / N^2,
term3 = (t(theta_mean) %*% Nj_cov %*% theta_mean) / N^2,
total = term1 + term2 + term3,
sigma = mod %>% spread_draws(sigma) %>% select(sigma) %>% unlist %>% mean
)
}
#mrp_sd_posteriorpredict(3)
mrp_sd_linpred = function(J,
main_survey_ = main_survey,
aux_survey_ = aux_survey,
population_ = population){
## make the income_level variable
main_survey_ = main_survey_ %>% mutate(
income_bracket = cut(
main_survey_$INCTOT,
breaks=quantile(population_$INCTOT,
probs = seq(0,1,by=1/J)),
include.lowest = TRUE,
labels = 1:J)
)
aux_survey_= aux_survey_ %>% mutate(
income_bracket = cut(
INCTOT,
breaks = quantile(population_$INCTOT,
probs = seq(0,1,by = 1/J)),
include.lowest = TRUE,
labels = 1:J)
)
## not needed, just for checking against correct Nj
population_ = population_ %>% mutate(
income_bracket = cut(
population_$INCTOT,
breaks = quantile(population_$INCTOT,
probs = seq(0,1,by = 1/J)),
include.lowest = TRUE,
labels = 1:J)
)
poststrat_true = population_ %>%
group_by(income_bracket) %>%
summarise(Nj = n()) %>%
ungroup()
## Estimate Nj_hat from the aux survey and compute covariance matrix
margins = population_ %>% group_by(PUMA) %>% summarise(Freq=n())
aux_design = svydesign(id = ~1,
strata = ~PUMA,
data = aux_survey_,
fpc = ~puma_size)
aux_rake = rake(design = aux_design,
list(~PUMA),
list(margins))
Nj_hat = svytotal(~income_bracket, aux_rake)
Nj_cov = vcov(Nj_hat)
## We would usually have to do a join here, but there's only one
## covariate in the model so we don't!
poststrat = Nj_hat %>%
coef %>%
enframe() %>%
mutate(income_bracket = stringr::str_extract(name, "[0-9]+")) %>%
rename(Nj_hat = value) %>%
select(-name)
## Estimate multilevel model
bye =capture.output(
mod = brm(formula = logRENTcentered ~ (1 | income_bracket),
prior = c(
prior(normal(0, 5), class=Intercept), # change sd to 2
prior(normal(0, 5), class = sd),
prior(normal(0, 5), class = sigma)
),
data = main_survey_,
chains=4,
cores=4,
refresh = 0,
backend = "cmdstanr",
), type = "output")
## Poststrat (both with Nj and Nj_hat just for checking)
prediction = posterior_linpred(mod,
newdata = poststrat,
allow_new_levels = TRUE)
prediction_ps = apply( prediction, 1, function(x){
sum(poststrat$Nj_hat * x) / sum(poststrat$Nj_hat)
})
prediction_ps_true = apply( prediction, 1, function(x){
sum(poststrat_true$Nj * x) / sum(poststrat_true$Nj)
})
# Lauren: I am going to use raw replicate weights
aux_replicates = as.svrepdesign(aux_rake, type = "bootstrap")
aux_replicates_rake = rake(design = aux_replicates,
list(~PUMA),
list(margins))
Nj_hat_replicate = svytotal(~income_bracket, aux_replicates_rake, return.replicates = TRUE)$replicates
prediction_ps_replicate = c()
for(rep in 1: nrow(Nj_hat_replicate)){
prediction_ps_replicate = c(prediction_ps_replicate,
apply( prediction, 1, function(x){
sum(Nj_hat_replicate[rep,] * x) / sum(Nj_hat_replicate[rep,])
}))
}
## Organise the output
N = length(population_$logRENTcentered)
theta_mean = colMeans(prediction)
theta_cov = cov(prediction)
tibble(mean_logRENT = mean(prediction_ps),
mean_logRENT_true = mean(prediction_ps_true),
poststrat_variance_trueNj = var(prediction_ps_true),
poststrat_variance_estNj = var(prediction_ps),
poststrat_variance_replicatewts = var(prediction_ps_replicate),
term1 = sum(diag(theta_cov %*% Nj_cov)) / N^2,
term2 = (t(poststrat$Nj_hat) %*% theta_cov %*% poststrat$Nj_hat) / N^2,
term3 = (t(theta_mean) %*% Nj_cov %*% theta_mean) / N^2,
total = term1 + term2 + term3)
}
est = tibble(J = c(3, seq(10, 100, by = 10))) %>%
mutate(out = purrr::map(J, mrp_sd_posteriorpredict)) %>%
unnest(out)
set.seed(30628)
library(tidyverse)
library(brms)
library(tidybayes)
library(survey)
p = 0.75
use_posteriorpredict = TRUE # if TRUE then poststratify posterior predictive
nystate = readRDS("nystate_fiveyear2015_2019.rds")
# five counties in new york city
P = nystate %>%
filter(COUNTYFIP %in% c(61,47,81,5,85) &
(RENT > 0) &
(INCTOT > 0) &
!(INCTOT %in% c(9999998,9999999))) %>%
select(RENT, INCTOT, PUMA, SEX, AGE, RACE, EDUC)
# make age into 5 categories, race into 5 categories, educational attainment into 5 categories, sex as binary variable
P  = P %>% mutate(
age_fivegroups = cut(
P$AGE,
breaks = c(min(P$AGE),21,40,65,80,max(P$AGE)),
include.lowest = TRUE,
labels = 1:5),
race_fivegroups = case_when(RACE == 1 ~ 1,
RACE == 2 ~ 2,
RACE == 3 ~ 3,
RACE %in% c(4,5,6) ~ 4,
RACE %in% c(7,8,9) ~ 5),
edu_fivegroups = case_when(EDUC == 0 ~ 1,
EDUC %in% c(1,2) ~ 2,
EDUC %in% c(3,4,5,6) ~ 3,
EDUC %in% c(7,8,9,10) ~ 4,
EDUC == 11 ~ 5),
sex_binary = case_when(SEX == 1 ~ 0,
SEX == 2 ~ 1)
)
# convert covariates to factors
P$age_fivegroups = as.factor(P$age_fivegroups)
P$race_fivegroups = as.factor(P$race_fivegroups)
P$edu_fivegroups = as.factor(P$edu_fivegroups)
P$index = 1:(dim(P)[1])
P$logRENTcentered = log(P$RENT) - mean(log(P$RENT))
# Dsize is nonrep sample size
Dsize = 1000
# ACSstratasize is the size of random sample in each PUMA strata when performing a stratified random sample of P
ACSstratasize = 3
# get population sizes of PUMA in P
P_PUMAsize = P %>% group_by(PUMA) %>% summarise(N = n()) %>% mutate(fraction = N/sum(N))
# Define probs to do PPSWOR for D2
P$INCTOTprobD2 = 0
P[P$INCTOT<=median(P$INCTOT), c("INCTOTprobD2")] = p
P[P$INCTOT>median(P$INCTOT), c("INCTOTprobD2")] = 1-p
# sample D2
D2indices = sample(x=1:dim(P)[1],
prob=P$INCTOTprobD2,
replace=FALSE,
size=Dsize)
D2 = P[D2indices,]
# ACS sample S without inclusion probs and defining incomebracket ####
pseudoACS_unweighted_beforeloop = c()
# Get stratified sample pseudoACS_unweighted, where strata are PUMA
for (PUMA_ in P_PUMAsize$PUMA) {
pseudoACS_unweighted_beforeloop = rbind(pseudoACS_unweighted_beforeloop,
P %>% filter(PUMA==PUMA_) %>% sample_n(ACSstratasize)
)
}
rm(D2indices,nystate,PUMA_)
gc()
main_survey = D2 %>% mutate(logRent = RENT,
logINCTOT = log(INCTOT))
population = P %>% mutate(logRent = RENT,
logINCTOT = log(INCTOT))
aux_survey = pseudoACS_unweighted_beforeloop %>%
mutate(logRent = RENT,
logINCTOT = log(INCTOT)) %>%
left_join(P_PUMAsize, by = "PUMA") %>%
rename(puma_size = N)
rm(D2, P, pseudoACS_unweighted_beforeloop, P_PUMAsize)
gc()
mrp_sd_posteriorpredict = function(J,
main_survey_ = main_survey,
aux_survey_ = aux_survey,
population_ = population){
## make the income_level variable
main_survey_ = main_survey_ %>% mutate(
income_bracket = cut(
main_survey_$INCTOT,
breaks=quantile(population_$INCTOT,
probs = seq(0,1,by=1/J)),
include.lowest = TRUE,
labels = 1:J)
)
aux_survey_= aux_survey_ %>% mutate(
income_bracket = cut(
INCTOT,
breaks = quantile(population_$INCTOT,
probs = seq(0,1,by = 1/J)),
include.lowest = TRUE,
labels = 1:J)
)
## not needed, just for checking against correct Nj
population_ = population_ %>% mutate(
income_bracket = cut(
population_$INCTOT,
breaks = quantile(population_$INCTOT,
probs = seq(0,1,by = 1/J)),
include.lowest = TRUE,
labels = 1:J)
)
poststrat_true = population_ %>%
group_by(income_bracket) %>%
summarise(Nj = n()) %>%
ungroup()
## Estimate Nj_hat from the aux survey and compute covariance matrix
margins = population_ %>% group_by(PUMA) %>% summarise(Freq=n())
aux_design = svydesign(id = ~1,
strata = ~PUMA,
data = aux_survey_,
fpc = ~puma_size)
aux_rake = rake(design = aux_design,
list(~PUMA),
list(margins))
Nj_hat = svytotal(~income_bracket, aux_rake)
Nj_cov = vcov(Nj_hat)
## We would usually have to do a join here, but there's only one
## covariate in the model so we don't!
poststrat = Nj_hat %>%
coef %>%
enframe() %>%
mutate(income_bracket = stringr::str_extract(name, "[0-9]+")) %>%
rename(Nj_hat = value) %>%
select(-name)
## Estimate multilevel model
bye = capture.output(
mod <- brm(formula = logRENTcentered ~ (1 | income_bracket),
prior = c(
prior(normal(0, 5), class=Intercept), # change sd to 2
prior(normal(0, 5), class = sd),
prior(normal(0, 5), class = sigma)
),
data = main_survey_,
chains=4,
cores=4,
refresh = 0,
backend = "cmdstanr",
), type = "output")
## Poststrat (both with Nj and Nj_hat just for checking)
prediction = posterior_predict(mod,
newdata = poststrat,
allow_new_levels = TRUE)
prediction_ps = apply( prediction, 1, function(x){
sum(poststrat$Nj_hat * x) / sum(poststrat$Nj_hat)
})
prediction_ps_true = apply( prediction, 1, function(x){
sum(poststrat_true$Nj * x) / sum(poststrat_true$Nj)
})
aux_replicates = as.svrepdesign(aux_rake, type = "bootstrap")
aux_replicates_rake = rake(design = aux_replicates,
list(~PUMA),
list(margins))
Nj_hat_replicate = svytotal(~income_bracket, aux_replicates_rake, return.replicates = TRUE)$replicates
prediction_ps_replicate = c()
for(rep in 1: nrow(Nj_hat_replicate)){
prediction_ps_replicate = c(prediction_ps_replicate,
apply( prediction, 1, function(x){
sum(Nj_hat_replicate[rep,] * x) / sum(Nj_hat_replicate[rep,])
}))
}
## Organise the output
N = length(population_$logRENTcentered)
theta_mean = colMeans(prediction)
theta_cov = cov(prediction)
tibble(mean_logRENT = mean(prediction_ps),
mean_logRENT_true = mean(prediction_ps_true),
poststrat_variance_trueNj = var(prediction_ps_true),
poststrat_variance_estNj = var(prediction_ps),
poststrat_variance_replicatewts = var(prediction_ps_replicate),
term1 = sum(diag(theta_cov %*% Nj_cov)) / N^2,
term2 = (t(poststrat$Nj_hat) %*% theta_cov %*% poststrat$Nj_hat) / N^2,
term3 = (t(theta_mean) %*% Nj_cov %*% theta_mean) / N^2,
total = term1 + term2 + term3,
sigma = mod %>% spread_draws(sigma) %>% select(sigma) %>% unlist %>% mean
)
}
#mrp_sd_posteriorpredict(3)
mrp_sd_linpred = function(J,
main_survey_ = main_survey,
aux_survey_ = aux_survey,
population_ = population){
## make the income_level variable
main_survey_ = main_survey_ %>% mutate(
income_bracket = cut(
main_survey_$INCTOT,
breaks=quantile(population_$INCTOT,
probs = seq(0,1,by=1/J)),
include.lowest = TRUE,
labels = 1:J)
)
aux_survey_= aux_survey_ %>% mutate(
income_bracket = cut(
INCTOT,
breaks = quantile(population_$INCTOT,
probs = seq(0,1,by = 1/J)),
include.lowest = TRUE,
labels = 1:J)
)
## not needed, just for checking against correct Nj
population_ = population_ %>% mutate(
income_bracket = cut(
population_$INCTOT,
breaks = quantile(population_$INCTOT,
probs = seq(0,1,by = 1/J)),
include.lowest = TRUE,
labels = 1:J)
)
poststrat_true = population_ %>%
group_by(income_bracket) %>%
summarise(Nj = n()) %>%
ungroup()
## Estimate Nj_hat from the aux survey and compute covariance matrix
margins = population_ %>% group_by(PUMA) %>% summarise(Freq=n())
aux_design = svydesign(id = ~1,
strata = ~PUMA,
data = aux_survey_,
fpc = ~puma_size)
aux_rake = rake(design = aux_design,
list(~PUMA),
list(margins))
Nj_hat = svytotal(~income_bracket, aux_rake)
Nj_cov = vcov(Nj_hat)
## We would usually have to do a join here, but there's only one
## covariate in the model so we don't!
poststrat = Nj_hat %>%
coef %>%
enframe() %>%
mutate(income_bracket = stringr::str_extract(name, "[0-9]+")) %>%
rename(Nj_hat = value) %>%
select(-name)
## Estimate multilevel model
bye = capture.output(
mod <- brm(formula = logRENTcentered ~ (1 | income_bracket),
prior = c(
prior(normal(0, 5), class=Intercept), # change sd to 2
prior(normal(0, 5), class = sd),
prior(normal(0, 5), class = sigma)
),
data = main_survey_,
chains=4,
cores=4,
refresh = 0,
backend = "cmdstanr",
), type = "output")
## Poststrat (both with Nj and Nj_hat just for checking)
prediction = posterior_linpred(mod,
newdata = poststrat,
allow_new_levels = TRUE)
prediction_ps = apply( prediction, 1, function(x){
sum(poststrat$Nj_hat * x) / sum(poststrat$Nj_hat)
})
prediction_ps_true = apply( prediction, 1, function(x){
sum(poststrat_true$Nj * x) / sum(poststrat_true$Nj)
})
# Lauren: I am going to use raw replicate weights
aux_replicates = as.svrepdesign(aux_rake, type = "bootstrap")
aux_replicates_rake = rake(design = aux_replicates,
list(~PUMA),
list(margins))
Nj_hat_replicate = svytotal(~income_bracket, aux_replicates_rake, return.replicates = TRUE)$replicates
prediction_ps_replicate = c()
for(rep in 1: nrow(Nj_hat_replicate)){
prediction_ps_replicate = c(prediction_ps_replicate,
apply( prediction, 1, function(x){
sum(Nj_hat_replicate[rep,] * x) / sum(Nj_hat_replicate[rep,])
}))
}
## Organise the output
N = length(population_$logRENTcentered)
theta_mean = colMeans(prediction)
theta_cov = cov(prediction)
tibble(mean_logRENT = mean(prediction_ps),
mean_logRENT_true = mean(prediction_ps_true),
poststrat_variance_trueNj = var(prediction_ps_true),
poststrat_variance_estNj = var(prediction_ps),
poststrat_variance_replicatewts = var(prediction_ps_replicate),
term1 = sum(diag(theta_cov %*% Nj_cov)) / N^2,
term2 = (t(poststrat$Nj_hat) %*% theta_cov %*% poststrat$Nj_hat) / N^2,
term3 = (t(theta_mean) %*% Nj_cov %*% theta_mean) / N^2,
total = term1 + term2 + term3)
}
est = tibble(J = c(3, seq(10, 100, by = 10))) %>%
mutate(out = purrr::map(J, mrp_sd_posteriorpredict)) %>%
unnest(out)
est_linpred = tibble(J = c(3, seq(10, 100, by = 10))) %>%
mutate(out = purrr::map(J, mrp_sd_linpred)) %>%
unnest(out)
#write_csv(est, file = "lauren_est.csv")
saveRDS(
rbind(
tibble(est %>% select(J, term1,term2,term3,total), Type = "Poststratifying posterior predictive distribution"),
tibble(est_linpred %>% select(J, term1,term2,term3,total), Type = "Poststratifying posterior linear predictor")
),
file=paste0("comparing_linpred_pp_",Dsize,"_",ACSstratasize,"_",p*100,".rds"),
)
gc()
set.seed(30628)
library(tidyverse)
library(brms)
library(tidybayes)
library(survey)
# p changes the representativeness of the main survey D. p = 0.5 is the most representative
p = 0.75
# Dsize is nonrep sample size
Dsize = 1000
# ACSstratasize is the size of random sample in each PUMA strata when performing a stratified random sample of P
ACSstratasize = 3
use_posteriorpredict = TRUE # if TRUE then poststratify posterior predictive
nystate = readRDS("nystate_fiveyear2015_2019.rds")
# five counties in new york city
P = nystate %>%
filter(COUNTYFIP %in% c(61,47,81,5,85) &
(RENT > 0) &
(INCTOT > 0) &
!(INCTOT %in% c(9999998,9999999))) %>%
select(RENT, INCTOT, PUMA, SEX, AGE, RACE, EDUC)
# make age into 5 categories, race into 5 categories, educational attainment into 5 categories, sex as binary variable
P  = P %>% mutate(
age_fivegroups = cut(
P$AGE,
breaks = c(min(P$AGE),21,40,65,80,max(P$AGE)),
include.lowest = TRUE,
labels = 1:5),
race_fivegroups = case_when(RACE == 1 ~ 1,
RACE == 2 ~ 2,
RACE == 3 ~ 3,
RACE %in% c(4,5,6) ~ 4,
RACE %in% c(7,8,9) ~ 5),
edu_fivegroups = case_when(EDUC == 0 ~ 1,
EDUC %in% c(1,2) ~ 2,
EDUC %in% c(3,4,5,6) ~ 3,
EDUC %in% c(7,8,9,10) ~ 4,
EDUC == 11 ~ 5),
sex_binary = case_when(SEX == 1 ~ 0,
SEX == 2 ~ 1)
)
# convert covariates to factors
P$age_fivegroups = as.factor(P$age_fivegroups)
P$race_fivegroups = as.factor(P$race_fivegroups)
P$edu_fivegroups = as.factor(P$edu_fivegroups)
P$index = 1:(dim(P)[1])
P$logRENTcentered = log(P$RENT) - mean(log(P$RENT))
# get population sizes of PUMA in P
P_PUMAsize = P %>% group_by(PUMA) %>% summarise(N = n()) %>% mutate(fraction = N/sum(N))
# Define probs to do PPSWOR for D2
P$INCTOTprobD2 = 0
P[P$INCTOT<=median(P$INCTOT), c("INCTOTprobD2")] = p
P[P$INCTOT>median(P$INCTOT), c("INCTOTprobD2")] = 1-p
# sample D2
D2indices = sample(x=1:dim(P)[1],
prob=P$INCTOTprobD2,
replace=FALSE,
size=Dsize)
D2 = P[D2indices,]
# ACS sample S without inclusion probs and defining incomebracket ####
pseudoACS_unweighted_beforeloop = c()
# Get stratified sample pseudoACS_unweighted, where strata are PUMA
for (PUMA_ in P_PUMAsize$PUMA) {
pseudoACS_unweighted_beforeloop = rbind(pseudoACS_unweighted_beforeloop,
P %>% filter(PUMA==PUMA_) %>% sample_n(ACSstratasize)
)
}
rm(D2indices,nystate,PUMA_)
gc()
main_survey = D2 %>% mutate(logRent = RENT,
logINCTOT = log(INCTOT))
population = P %>% mutate(logRent = RENT,
logINCTOT = log(INCTOT))
aux_survey = pseudoACS_unweighted_beforeloop %>%
mutate(logRent = RENT,
logINCTOT = log(INCTOT)) %>%
left_join(P_PUMAsize, by = "PUMA") %>%
rename(puma_size = N)
rm(D2, P, pseudoACS_unweighted_beforeloop, P_PUMAsize)
gc()
